# 打飞机小游戏 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 使用 HTML5 Canvas + 原生 JavaScript（ES6+）开发一款完整可玩的纵向卷轴射击游戏。

**Architecture:** 单 Canvas 渲染，requestAnimationFrame 驱动的游戏主循环，ES6 Class 组织各实体（Player/Enemy/Bullet/UI），AABB 矩形碰撞检测，对象池管理子弹与敌机以保持 60 FPS。

**Tech Stack:** HTML5 Canvas API、原生 JavaScript ES6+、无任何第三方框架

---

## 多代理协作策略

| 代理 | 负责模块 | 并行/顺序 |
|------|----------|-----------|
| Agent-A (frontend-specialist) | `index.html` + `src/main.js` 游戏主循环 | 阶段一（并行） |
| Agent-B (frontend-specialist) | `src/player.js` + `src/bullet.js` | 阶段一（并行） |
| Agent-C (frontend-specialist) | `src/enemy.js` 敌机系统 | 阶段一（并行） |
| Agent-D (frontend-specialist) | `src/ui.js` UI 渲染 | 阶段一（并行） |
| Agent-E (code-reviewer) | 集成测试 + 代码审查 | 阶段二（顺序） |

---

## 目标文件结构

```
game-plain/
├── index.html
└── src/
    ├── main.js      # 游戏入口、主循环、状态管理
    ├── player.js    # 玩家飞机类
    ├── enemy.js     # 敌机类（普通/精英）
    ├── bullet.js    # 子弹类 + 对象池
    └── ui.js        # UI 渲染（得分/生命/关卡）
```

---

## 阶段一：并行开发（Agent A/B/C/D 同时执行）

---

### Task 1 [Agent-A]：index.html + main.js 游戏骨架

**Files:**
- Create: `index.html`
- Create: `src/main.js`

**Step 1: 创建 index.html**

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>打飞机</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a1a; display: flex; justify-content: center; align-items: center; height: 100vh; }
    canvas { display: block; border: 1px solid #333; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script type="module" src="src/main.js"></script>
</body>
</html>
```

**Step 2: 创建 src/main.js 游戏主循环骨架**

```javascript
import { Player } from './player.js';
import { EnemyManager } from './enemy.js';
import { BulletPool } from './bullet.js';
import { UI } from './ui.js';

const CANVAS_W = 480;
const CANVAS_H = 640;

class Game {
  constructor() {
    this.canvas = document.getElementById('gameCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.canvas.width = CANVAS_W;
    this.canvas.height = CANVAS_H;

    this.state = 'playing'; // 'playing' | 'gameover'
    this.score = 0;
    this.lives = 3;
    this.level = 1;
    this.frameCount = 0;

    this.bulletPool = new BulletPool(50);
    this.player = new Player(CANVAS_W / 2, CANVAS_H - 80, this.bulletPool);
    this.enemyManager = new EnemyManager(CANVAS_W, CANVAS_H);
    this.ui = new UI(this.ctx, CANVAS_W, CANVAS_H);

    this.lastTime = 0;
    this._bindInput();
  }

  _bindInput() {
    this.keys = {};
    window.addEventListener('keydown', e => { this.keys[e.code] = true; });
    window.addEventListener('keyup',   e => { this.keys[e.code] = false; });
  }

  update(dt) {
    if (this.state !== 'playing') return;

    this.frameCount++;
    this.player.update(dt, this.keys, this.canvas.width);
    this.enemyManager.update(dt, this.frameCount, this.level);
    this.bulletPool.update(dt);

    // 子弹 vs 敌机碰撞
    for (const bullet of this.bulletPool.active) {
      for (const enemy of this.enemyManager.enemies) {
        if (!bullet.active || !enemy.active) continue;
        if (rectsOverlap(bullet, enemy)) {
          bullet.active = false;
          enemy.hp -= bullet.damage;
          if (enemy.hp <= 0) {
            enemy.active = false;
            this.score += enemy.score;
          }
        }
      }
    }

    // 敌机 vs 玩家碰撞
    for (const enemy of this.enemyManager.enemies) {
      if (!enemy.active) continue;
      if (rectsOverlap(enemy, this.player)) {
        enemy.active = false;
        this.lives--;
        if (this.lives <= 0) this.state = 'gameover';
      }
    }

    // 关卡升级：每 500 分升一级
    this.level = Math.floor(this.score / 500) + 1;
  }

  render() {
    const ctx = this.ctx;
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    if (this.state === 'playing') {
      this.player.render(ctx);
      this.enemyManager.render(ctx);
      this.bulletPool.render(ctx);
      this.ui.render(this.score, this.lives, this.level);
    } else {
      this.ui.renderGameOver(this.score);
    }
  }

  loop(timestamp) {
    const dt = Math.min((timestamp - this.lastTime) / 1000, 0.05); // 最大 50ms 防跳帧
    this.lastTime = timestamp;
    this.update(dt);
    this.render();
    requestAnimationFrame(ts => this.loop(ts));
  }

  start() {
    requestAnimationFrame(ts => {
      this.lastTime = ts;
      this.loop(ts);
    });
  }
}

function rectsOverlap(a, b) {
  return a.x < b.x + b.w &&
         a.x + a.w > b.x &&
         a.y < b.y + b.h &&
         a.y + a.h > b.y;
}

const game = new Game();
game.start();
```

**Step 3: 验证**

用浏览器打开 `index.html`，控制台无报错（此时其他模块尚未实现，会有 import 错误，属正常）。

---

### Task 2 [Agent-B]：player.js + bullet.js

**Files:**
- Create: `src/bullet.js`
- Create: `src/player.js`

**Step 1: 创建 src/bullet.js（含对象池）**

```javascript
export class Bullet {
  constructor() {
    this.x = 0; this.y = 0;
    this.w = 4; this.h = 12;
    this.speed = 600;   // px/s
    this.damage = 1;
    this.active = false;
  }

  init(x, y) {
    this.x = x - this.w / 2;
    this.y = y;
    this.active = true;
  }

  update(dt) {
    this.y -= this.speed * dt;
    if (this.y + this.h < 0) this.active = false;
  }

  render(ctx) {
    ctx.fillStyle = '#00ffff';
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 6;
    ctx.fillRect(this.x, this.y, this.w, this.h);
    ctx.shadowBlur = 0;
  }
}

export class BulletPool {
  constructor(size) {
    this.pool = Array.from({ length: size }, () => new Bullet());
    this.active = [];
  }

  spawn(x, y) {
    const b = this.pool.find(b => !b.active);
    if (!b) return; // 池满则跳过
    b.init(x, y);
    this.active.push(b);
  }

  update(dt) {
    for (const b of this.active) b.update(dt);
    // 回收非活跃子弹
    this.active = this.active.filter(b => b.active);
  }

  render(ctx) {
    for (const b of this.active) b.render(ctx);
  }
}
```

**Step 2: 创建 src/player.js**

```javascript
export class Player {
  constructor(x, y, bulletPool) {
    this.x = x;
    this.y = y;
    this.w = 40;
    this.h = 40;
    this.speed = 300;       // px/s
    this.bulletPool = bulletPool;
    this.fireRate = 0.15;   // 秒/发
    this._fireCooldown = 0;
    this.invincible = 0;    // 无敌帧（秒）
  }

  update(dt, keys, canvasW) {
    // 移动
    if (keys['ArrowLeft']  || keys['KeyA']) this.x -= this.speed * dt;
    if (keys['ArrowRight'] || keys['KeyD']) this.x += this.speed * dt;
    // 边界限制
    this.x = Math.max(0, Math.min(canvasW - this.w, this.x));

    // 射击
    this._fireCooldown -= dt;
    if ((keys['Space'] || keys['KeyZ']) && this._fireCooldown <= 0) {
      this.bulletPool.spawn(this.x + this.w / 2, this.y);
      this._fireCooldown = this.fireRate;
    }

    if (this.invincible > 0) this.invincible -= dt;
  }

  render(ctx) {
    // 无敌时闪烁
    if (this.invincible > 0 && Math.floor(this.invincible * 10) % 2 === 0) return;

    ctx.save();
    ctx.translate(this.x + this.w / 2, this.y + this.h / 2);

    // 机身
    ctx.fillStyle = '#4af';
    ctx.beginPath();
    ctx.moveTo(0, -20);
    ctx.lineTo(-18, 18);
    ctx.lineTo(0, 10);
    ctx.lineTo(18, 18);
    ctx.closePath();
    ctx.fill();

    // 引擎光
    ctx.fillStyle = '#ff6600';
    ctx.beginPath();
    ctx.ellipse(0, 16, 6, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}
```

**Step 3: 验证**

- 玩家飞机在底部居中渲染
- 左右方向键/WASD 可移动，不超出边界
- 空格/Z 键发射子弹，子弹向上飞出屏幕后消失

---

### Task 3 [Agent-C]：enemy.js 敌机系统

**Files:**
- Create: `src/enemy.js`

**Step 1: 创建 src/enemy.js**

```javascript
const ENEMY_TYPES = {
  normal: {
    w: 36, h: 36,
    speed: 120,
    hp: 1,
    score: 10,
    color: '#f44',
  },
  elite: {
    w: 48, h: 48,
    speed: 80,
    hp: 3,
    score: 50,
    color: '#f80',
  },
};

export class Enemy {
  constructor() {
    this.x = 0; this.y = 0;
    this.w = 36; this.h = 36;
    this.speed = 120;
    this.hp = 1;
    this.score = 10;
    this.color = '#f44';
    this.type = 'normal';
    this.active = false;
  }

  init(x, y, type = 'normal') {
    const cfg = ENEMY_TYPES[type];
    this.x = x; this.y = y;
    this.w = cfg.w; this.h = cfg.h;
    this.speed = cfg.speed;
    this.hp = cfg.hp;
    this.score = cfg.score;
    this.color = cfg.color;
    this.type = type;
    this.active = true;
  }

  update(dt, canvasH) {
    this.y += this.speed * dt;
    if (this.y > canvasH) this.active = false;
  }

  render(ctx) {
    ctx.save();
    ctx.translate(this.x + this.w / 2, this.y + this.h / 2);
    ctx.rotate(Math.PI); // 朝下

    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(0, -this.h / 2 + 4);
    ctx.lineTo(-this.w / 2 + 4, this.h / 2 - 4);
    ctx.lineTo(0, this.h / 2 - 10);
    ctx.lineTo(this.w / 2 - 4, this.h / 2 - 4);
    ctx.closePath();
    ctx.fill();

    // 精英敌机显示 HP 条
    if (this.type === 'elite') {
      const maxHp = ENEMY_TYPES.elite.hp;
      ctx.fillStyle = '#333';
      ctx.fillRect(-this.w / 2, -this.h / 2 - 8, this.w, 4);
      ctx.fillStyle = '#0f0';
      ctx.fillRect(-this.w / 2, -this.h / 2 - 8, this.w * (this.hp / maxHp), 4);
    }

    ctx.restore();
  }
}

export class EnemyManager {
  constructor(canvasW, canvasH) {
    this.canvasW = canvasW;
    this.canvasH = canvasH;
    this.enemies = Array.from({ length: 30 }, () => new Enemy());
    this._spawnTimer = 0;
  }

  _spawnInterval(level) {
    // 随关卡加快生成速度，最快 0.5s
    return Math.max(0.5, 1.5 - level * 0.1);
  }

  _eliteChance(level) {
    // 随关卡提升精英概率，最高 40%
    return Math.min(0.4, 0.05 + level * 0.03);
  }

  update(dt, frameCount, level) {
    this._spawnTimer += dt;
    if (this._spawnTimer >= this._spawnInterval(level)) {
      this._spawnTimer = 0;
      this._spawn(level);
    }
    for (const e of this.enemies) {
      if (e.active) e.update(dt, this.canvasH);
    }
    // 清理离屏敌机
    for (const e of this.enemies) {
      if (e.active && e.y > this.canvasH) e.active = false;
    }
  }

  _spawn(level) {
    const e = this.enemies.find(e => !e.active);
    if (!e) return;
    const type = Math.random() < this._eliteChance(level) ? 'elite' : 'normal';
    const cfg = ENEMY_TYPES[type];
    const x = Math.random() * (this.canvasW - cfg.w);
    e.init(x, -cfg.h, type);
  }

  render(ctx) {
    for (const e of this.enemies) {
      if (e.active) e.render(ctx);
    }
  }
}
```

**Step 3: 验证**

- 敌机从顶部随机位置生成，向下移动
- 普通敌机（红色）和精英敌机（橙色，带 HP 条）均正常渲染
- 敌机飞出底部后自动回收

---

### Task 4 [Agent-D]：ui.js UI 渲染

**Files:**
- Create: `src/ui.js`

**Step 1: 创建 src/ui.js**

```javascript
export class UI {
  constructor(ctx, canvasW, canvasH) {
    this.ctx = ctx;
    this.canvasW = canvasW;
    this.canvasH = canvasH;
  }

  render(score, lives, level) {
    const ctx = this.ctx;
    ctx.save();
    ctx.font = 'bold 16px monospace';
    ctx.fillStyle = '#fff';

    // 得分
    ctx.textAlign = 'left';
    ctx.fillText(`SCORE: ${score}`, 12, 24);

    // 关卡
    ctx.textAlign = 'center';
    ctx.fillText(`LEVEL ${level}`, this.canvasW / 2, 24);

    // 生命值（心形图标）
    ctx.textAlign = 'right';
    const hearts = '♥'.repeat(lives) + '♡'.repeat(Math.max(0, 3 - lives));
    ctx.fillStyle = '#f55';
    ctx.fillText(hearts, this.canvasW - 12, 24);

    ctx.restore();
  }

  renderGameOver(score) {
    const ctx = this.ctx;
    ctx.save();

    // 半透明遮罩
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, this.canvasW, this.canvasH);

    ctx.textAlign = 'center';

    ctx.font = 'bold 48px monospace';
    ctx.fillStyle = '#f44';
    ctx.fillText('GAME OVER', this.canvasW / 2, this.canvasH / 2 - 40);

    ctx.font = 'bold 24px monospace';
    ctx.fillStyle = '#fff';
    ctx.fillText(`最终得分: ${score}`, this.canvasW / 2, this.canvasH / 2 + 10);

    ctx.font = '16px monospace';
    ctx.fillStyle = '#aaa';
    ctx.fillText('刷新页面重新开始', this.canvasW / 2, this.canvasH / 2 + 50);

    ctx.restore();
  }
}
```

**Step 3: 验证**

- 左上角显示 SCORE，中间显示 LEVEL，右上角显示生命值心形
- 游戏结束时显示半透明遮罩 + GAME OVER + 最终得分

---

## 阶段二：集成与审查（Agent-E 顺序执行）

---

### Task 5 [Agent-E]：集成测试 + 代码审查

**Files:**
- Review: `index.html`, `src/main.js`, `src/player.js`, `src/enemy.js`, `src/bullet.js`, `src/ui.js`

**Step 1: 集成验证清单**

在浏览器中打开 `index.html`，逐项验证：

| 验证项 | 预期结果 |
|--------|----------|
| 页面加载 | Canvas 居中显示，无控制台报错 |
| 玩家渲染 | 底部居中显示蓝色飞机 |
| 玩家移动 | ←→ / WASD 左右移动，不超出边界 |
| 玩家射击 | 空格/Z 键发射青色子弹，向上飞出 |
| 敌机生成 | 顶部随机位置生成红/橙色敌机，向下移动 |
| 碰撞检测 | 子弹击中敌机→敌机消失+得分增加 |
| 精英敌机 | 橙色敌机需 3 发子弹击毁，显示 HP 条 |
| 生命扣除 | 敌机碰到玩家→生命值减少 |
| 游戏结束 | 生命值归零→显示 GAME OVER 画面 |
| 关卡升级 | 每 500 分 LEVEL 数字增加，敌机生成加快 |
| 帧率 | 浏览器 DevTools Performance 面板确认 ~60 FPS |

**Step 2: 代码审查要点**

- [ ] `rectsOverlap` 函数是否正确（AABB 碰撞）
- [ ] 对象池是否正确回收（无内存泄漏）
- [ ] `dt` 是否有上限保护（防止标签切换后跳帧）
- [ ] 边界检测是否考虑了飞机宽度
- [ ] 精英敌机 HP 初始值与 `ENEMY_TYPES.elite.hp` 是否一致

**Step 3: 已知优化点（可选，YAGNI 原则暂不实现）**

- 背景星空滚动效果
- 爆炸粒子特效
- 音效系统
- 移动端触控支持
- 本地存储最高分

---

## 执行选项

计划已保存至 `plans/Init-v202602191004.md`。

**1. 子代理驱动（当前会话）** — 每个 Task 派发独立子代理，任务间可审查，快速迭代

**2. 并行会话（独立会话）** — 在新会话中使用 executing-plans 技能，批量执行并设置检查点

**请选择执行方式？**
